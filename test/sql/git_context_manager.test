# name: test/sql/git_context_manager.test
# description: Comprehensive tests for GitContextManager unified architecture
# group: [duck_tails]

require duck_tails

# Use __BUILD_DIRECTORY__ to ensure we load the freshly built extension
statement ok
SET extension_directory='__BUILD_DIRECTORY__/extension';

statement ok
PRAGMA enable_verification

# NOTE: This test requires fixtures to be set up. Use: make fixtures

# Test 1: Basic git:// URI processing with valid ref
statement ok
SELECT 'git_context_basic_uri' as test_name

# Test 2: Filesystem path processing with repository discovery
statement ok 
SELECT 'git_context_filesystem_path' as test_name

# Test 3: Invalid URI parsing
statement error
SELECT * FROM git_log_each('git://invalid@@@uri')
----
unable to parse OID

# Test 4: Valid URI with invalid file path - should return 0 rows for git_tree
query I
SELECT COUNT(*) = 0 as empty_result FROM git_tree('git://test/tmp/main-repo/nonexistent_file.txt@HEAD')
----
true

# Test 5: Valid URI with valid file path - should return 1 row for git_tree
query I
SELECT COUNT(*) = 1 as single_file FROM git_tree('git://test/tmp/main-repo/README.md@HEAD')
----
true

# Test 6: git_log with file filtering - should return only commits that touched the file
query I
SELECT COUNT(*) <= 5 as filtered_commits FROM git_log_each('git://test/tmp/main-repo/README.md@HEAD')
----
true

# Test 7: Consistency test - all git_* functions should handle refs the same way
statement error
SELECT * FROM git_tree('git://test/tmp/main-repo@invalid@@ref')
----
unable to parse OID

statement error 
SELECT * FROM git_log_each('git://test/tmp/main-repo@invalid@@ref')
----
unable to parse OID

statement error
SELECT * FROM git_read('git://test/tmp/main-repo/README.md@invalid@@ref')
----
unable to parse OID

# Test 8: Repository cache efficiency - multiple calls should reuse repository
query I
SELECT COUNT(*) > 0 as has_commits_1 FROM git_log('git://test/tmp/main-repo@HEAD')
----
true

query I
SELECT COUNT(*) > 0 as has_commits_2 FROM git_log('git://test/tmp/main-repo@HEAD')
----
true

# Test 9: Different refs in same repository
query I
SELECT COUNT(*) >= 0 as valid_head FROM git_tree('git://test/tmp/main-repo@HEAD')
----
true

# Test 10: File path extraction and validation
query I
SELECT COUNT(*) = count_if(file_path = 'README.md') as correct_file_path 
FROM git_tree('git://test/tmp/main-repo/README.md@HEAD')
----
true

# Test 11: Complex LATERAL join operations (tests repository cache)
query I
WITH test_files(file) AS (
    VALUES ('README.md'), ('src/main.py')
)
SELECT COUNT(*) >= 1 as has_results
FROM test_files t, LATERAL git_tree_each('git://test/tmp/main-repo/' || t.file || '@HEAD') g
----
true

# Test 12: Error consistency across all functions - non-existent repository
statement error
SELECT * FROM git_log('/nonexistent/repository/path')
----
Failed to resolve repository path '/nonexistent/repository/path'

statement error
SELECT * FROM git_tree('/nonexistent/repository/path@HEAD')  
----
Failed to resolve repository path '/nonexistent/repository/path@HEAD'

# Test 13: Mixed valid and invalid URIs in LATERAL context
query I
WITH test_uris(uri) AS (
    VALUES 
        ('git://test/tmp/main-repo/README.md@HEAD'),
        (NULL)
)
SELECT COUNT(*) = 1 as one_valid_result 
FROM test_uris t, LATERAL git_tree_each(t.uri) g
WHERE t.uri IS NOT NULL
----
true

# Test 14: Repository path resolution consistency
query I 
SELECT COUNT(DISTINCT repo_path) = 1 as consistent_repo_path
FROM git_log('git://test/tmp/main-repo@HEAD')
----
true

# Test 15: File path filtering with subdirectories
query I
SELECT COUNT(*) >= 0 as has_src_files FROM git_tree('git://test/tmp/main-repo/src@HEAD')
----
true

# Test 16: Performance test - large LATERAL operation should not timeout
statement ok
CREATE TEMP TABLE refs AS 
SELECT 'HEAD' as ref 
UNION ALL SELECT 'HEAD'
UNION ALL SELECT 'HEAD'
UNION ALL SELECT 'HEAD'
UNION ALL SELECT 'HEAD'

query I
SELECT COUNT(*) >= 0 as performance_test
FROM refs r, LATERAL git_tree_each('git://test/tmp/main-repo@' || r.ref) g
----
true

# Test 17: Ref validation with various ref types
query I
SELECT COUNT(*) > 0 as valid_head_ref FROM git_tree('git://test/tmp/main-repo@HEAD')
----
true

# Note: Specific commit hash test would need fixture-specific hash
# query I
# SELECT COUNT(*) > 0 as valid_hash_ref FROM git_tree('git://test/tmp/main-repo@abc1234')
# ----
# true

# Test 18: Final consistency check - same file accessed via different git functions
statement ok
CREATE TEMP TABLE consistency_check AS
SELECT 'README.md' as file_path, COUNT(*) as tree_count
FROM git_tree('git://test/tmp/main-repo/README.md@HEAD')

# All tests passed - GitContextManager is working correctly
statement ok
SELECT 'GitContextManager tests completed successfully' as result