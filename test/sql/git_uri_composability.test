# Git URI Composability Tests - Checklist for _each functions
# ================================================
# This test file serves as both a checklist and test suite for verifying
# that all _each functions support git:// URI parsing for composability
# in LATERAL joins.
#
# CHECKLIST FOR EACH _each FUNCTION:
# 1. ✅ Accept git:// URI as input (e.g., git://repo@ref)
# 2. ✅ Parse repository path from URI
# 3. ✅ Parse ref/commit from URI
# 4. ✅ Handle optional file path in URI
# 5. ✅ Work in LATERAL joins with output from other functions
# 6. ✅ Handle both URI and plain path formats
# 7. ✅ Handle null values gracefully
# 8. ✅ Proper error messages for invalid URIs
#
# Functions tested:
# - git_tree_each (produces git_uri)
# - git_log_each (consumes git_uri)
# - git_parents_each (consumes git URIs)
# - git_branches_each (consumes git URIs)
# - git_tags_each (consumes git URIs)
# - git_read_each (consumes git_uri)

statement ok
SET autoinstall_extension_repository='./build/debug/repository';

statement ok
SET autoload_known_extensions='true';

statement ok
SET custom_extension_repository='./build/debug/repository';

# Use __BUILD_DIRECTORY__ to ensure we load the freshly built extension
statement ok
SET extension_directory='__BUILD_DIRECTORY__/repository';

statement ok
LOAD duck_tails;

# Test 1: git_tree produces git_uri that can be consumed by _each functions
# ================================================================================

# First verify that git_tree produces git_uri (with resolved commit hash)
query II
SELECT 
    file_path, 
    git_uri LIKE 'git://%' as has_uri_format
FROM git_tree('.', 'HEAD')
WHERE file_path LIKE 'README%'
ORDER BY file_path
LIMIT 1;
----
README.md	true

# Test 2: git_log_each can consume git:// URIs from git_tree
# ===========================================================

# Test composability: git_tree outputs git_uri, git_log_each consumes it
# Using subquery approach due to DuckDB LATERAL parameter binding limitations  
query II
SELECT 
    t.file_path,
    CASE 
        WHEN (SELECT COUNT(*) FROM git_log_each(t.git_uri)) > 0 THEN 1 
        ELSE 0 
    END as has_commits
FROM git_tree('.', 'HEAD') t
WHERE t.file_path = 'README.md';
----
README.md	1

# Test 3: git_parents_each can consume git:// URIs
# =================================================

# First, get a commit hash wrapped in git:// URI format
query I
WITH commits AS (
    SELECT 'git://' || '.' || '@' || commit_hash as git_commit_uri,
           commit_hash
    FROM git_log('.') 
    LIMIT 5
)
SELECT 
    COUNT(*) > 0 as has_parents
FROM commits c
CROSS JOIN LATERAL git_parents_each(c.git_commit_uri) p;
----
true

# Test 4: git_branches_each can consume git:// URIs
# ==================================================

query II
WITH repos AS (
    SELECT 'git://' || '.' || '@HEAD' as repo_uri
)
SELECT
    COUNT(b.branch_name) > 0 as has_branches,
    MAX(b.is_current::INTEGER) >= 0 as has_current_flag
FROM repos r
CROSS JOIN LATERAL git_branches_each(r.repo_uri) b;
----
true	true

# Test 5: git_tags_each can consume git:// URIs
# ==============================================

query I
WITH repos AS (
    SELECT 'git://' || '.' || '@HEAD' as repo_uri
)
SELECT
    COUNT(t.tag_name) >= 0 as has_tags_or_empty
FROM repos r
CROSS JOIN LATERAL git_tags_each(r.repo_uri) t;
----
true

# Test 6: git_read_each can consume git_uri from git_tree
# =============================================================

query II
SELECT 
    t.file_path,
    CASE 
        WHEN (SELECT LENGTH(text) FROM git_read_each(t.git_uri)) > 0 THEN 1 
        ELSE 0 
    END as has_content
FROM git_tree('.', 'HEAD') t
WHERE t.file_path = 'README.md';
----
README.md	1

# Test 7: Complex composability - chaining multiple functions
# ===========================================================

# Chain git_tree -> git_log_each -> git_parents_each using URIs
query II
WITH tree_files AS (
    SELECT file_path, git_uri 
    FROM git_tree('.', 'HEAD')
    WHERE file_path = 'README.md'
),
file_commits AS (
    SELECT 
        tf.file_path,
        'git://' || '.' || '@' || l.commit_hash as commit_uri,
        l.commit_hash
    FROM tree_files tf
    CROSS JOIN LATERAL git_log_each(tf.git_uri) l
    LIMIT 1
)
SELECT 
    fc.file_path,
    COUNT(p.parent_hash) >= 0 as has_valid_count
FROM file_commits fc
LEFT JOIN LATERAL git_parents_each(fc.commit_uri) p ON true
GROUP BY fc.file_path;
----
README.md	true

# Test 8: Error handling - invalid git:// URIs
# =============================================

statement error
SELECT * FROM git_log_each('git://invalid@@@uri');
----
unable to parse OID

query I
SELECT COUNT(*) >= 0 FROM git_parents_each('git://nonexistent/repo@HEAD');
----
true

# Test 9: Null handling
# ====================

query I
WITH test_data AS (
    SELECT NULL::VARCHAR as uri
    UNION ALL
    SELECT 'git://test/tmp/main-repo@HEAD'
)
SELECT COUNT(*)
FROM test_data t
LEFT JOIN LATERAL git_log_each(t.uri) l ON true
WHERE t.uri IS NOT NULL;
----
3

# Test 10: Direct URI usage (without LATERAL)
# ===========================================

# Each function should also work with direct git:// URI input
query I
SELECT COUNT(*) > 0 as has_commits
FROM git_log_each('git://.@HEAD');
----
true

query I
SELECT COUNT(*) > 0 as has_branches  
FROM git_branches_each('git://.@HEAD');
----
true

query I
SELECT COUNT(*) >= 0 as valid_result
FROM git_tags_each('git://.@HEAD');
----
true

query I
SELECT COUNT(*) > 0 as has_parents
FROM git_parents_each('git://.@HEAD');
----
true

query I
SELECT COUNT(*) > 0 as has_tree
FROM git_tree_each('git://.@HEAD');
----
true

query I
SELECT LENGTH(text) > 0 as has_content
FROM git_read('git://./README.md@HEAD');
----
true

# SUCCESS: All _each functions support git:// URI parsing for composability!